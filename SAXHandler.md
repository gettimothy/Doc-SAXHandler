# Table of Contents1.  [SAXHandler](#orgb798e39)    1.  [Introduction](#org2ebf4f6)    2.  [Todo](#org55fff17)    3.  [SaxHandler Class Comment](#org07020bd)    4.  [Example Data](#org962ce4e)        1.  [Method One](#orgf4d2ff6)        2.  [Method Two](#org5476009)    5.  [Interrupting Parsing](#org6c8cfbe)    6.  [Parse Incrementally](#org865b657)    7.  [Modifying Security Limits](#org3dd3765)    8.  [Definitions](#org3c43fc2)    9.  [Bibliography](#org129a665)<a id="orgb798e39"></a># SAXHandler<a id="org2ebf4f6"></a>## Introduction        These are my working notes as I study the Monty XML SAXHandler.    I will be building first a small example  and later a larger exmple    insert something witty and informative here.<a id="org55fff17"></a>## Todoget good definitions on Drivers vs Handlers (and other things)<a id="org07020bd"></a>## SaxHandler Class Comment    This class is an event-handling XML parser. To use it, subclass it and override event handlers in the "handling" categories, such as #startDocument, #startElement:attributes:, #endElement:, and #endDocument.        By default XML namespace support and validation are enabled but not external entity resolution.        Once the subclass is ready, use the class "parsing" messages to parse XML:    	result := SAXHandlerSubclass parse: xmlStringOrStream.    	resultFromURL := SAXHandlerSubclass parseURL: xmlURLString.    	resultFromFile := SAXHandlerSubclass parseFileNamed: xmlFileName.        The class "instance creation" messages create and return new parsers on the input so they can be configured with messages in the  "configuring" category before parsing:    	result :=    		(SAXHandlerSubclass on: xmlStringOrStream)    			isValidating: true;    			resolvesExternalEntities: true;    			parseDocument.        #interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil:     	result :=    		(SAXHandlerSubclass on: xmlStringOrStream)    			parseDocumentWhile: [self shouldKeepParsing].        To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:    	(handler := SAXHandlerSubclass on: xmlStringOrStream)    		isValidating: false;     		preservesUndeclaredEntityReferences: true.    	parser := handler parser.        	"Only parse the first 10 tokens:"    	10 timesRepeat: [parser parseToken].        There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:    	result :=    		(SAXHandlerSubclass on: xmlStringOrStream)    			removeLimits;    			documentReadLimit: newReadLimit;    			maxEntityReplacementDepth: newMaxEntityDepth;    			parseDocument.    		    #optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.<a id="org962ce4e"></a>## Example Data<a id="orgf4d2ff6"></a>### Method One        |ios result|        ios := ReadStream on:'<?xml version="1.0" encoding="UTF-8"?>            <bookstore>            <book category="COOKING">          <title lang="en">Everyday Italian</title>          <author>Giada De Laurentiis</author>          <year>2005</year>          <price>30.00</price>        </book>            <book category="CHILDREN">          <title lang="en">Harry Potter</title>          <author>J K. Rowling</author>          <year>2005</year>          <price>29.99</price>        </book>            <book category="WEB">          <title lang="en">XQuery Kick Start</title>          <author>James McGovern</author>          <author>Per Bothner</author>          <author>Kurt Cagle</author>          <author>James Linn</author>          <author>Vaidyanathan Nagarajan</author>          <year>2003</year>          <price>49.99</price>        </book>            <book category="WEB">          <title lang="en">Learning XML</title>          <author>Erik T. Ray</author>          <year>2003</year>          <price>39.95</price>        </book>            </bookstore>'.        result:=ZStudySaxHandler parse: ios.    result inspect.<a id="org5476009"></a>### Method Two<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"><colgroup><col  class="org-left" /></colgroup><tbody><tr><td class="org-left">ios result</td></tr></tbody></table>ios := ReadStream on:'<?xml version="1.0" encoding="UTF-8"?><bookstore><book category="COOKING">  <title lang="en">Everyday Italian</title>  <author>Giada De Laurentiis</author>  <year>2005</year>  <price>30.00</price></book><book category="CHILDREN">  <title lang="en">Harry Potter</title>  <author>J K. Rowling</author>  <year>2005</year>  <price>29.99</price></book><book category="WEB">  <title lang="en">XQuery Kick Start</title>  <author>James McGovern</author>  <author>Per Bothner</author>  <author>Kurt Cagle</author>  <author>James Linn</author>  <author>Vaidyanathan Nagarajan</author>  <year>2003</year>  <price>49.99</price></book><book category="WEB">  <title lang="en">Learning XML</title>  <author>Erik T. Ray</author>  <year>2003</year>  <price>39.95</price></book></bookstore>'.result :=	(ZStudySaxHandler on: ios)		isValidating: true;		resolvesExternalEntities: true;		parseDocument. <a id="org6c8cfbe"></a>## Interrupting Parsing    #interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil:     	result :=    		(SAXHandlerSubclass on: xmlStringOrStream)    			parseDocumentWhile: [self shouldKeepParsing].<a id="org865b657"></a>## Parse Incrementally    To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:    	(handler := SAXHandlerSubclass on: xmlStringOrStream)    		isValidating: false;     		preservesUndeclaredEntityReferences: true.    	parser := handler parser.        	"Only parse the first 10 tokens:"    	10 timesRepeat: [parser parseToken].<a id="org3dd3765"></a>## Modifying Security Limits        There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:    	    result :=    		    (SAXHandlerSubclass on: xmlStringOrStream)    			    removeLimits;    			    documentReadLimit: newReadLimit;    			    maxEntityReplacementDepth: newMaxEntityDepth;    			    parseDocument.            #optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.        It does this:            optimizeForLargeDocuments    	    "use this for faster parsing/less memory use with large documents"        	    self    		    isValidating: false;    		    usesNamespaces: false;    		    documentReadLimit: nil<a id="org3c43fc2"></a>## Definitions        1. PULL Parser        A pull is when the handler says to the parser, "give me the next foo."        Think XPath on an XMLDocument.    2. PUSH Parser      A push is when the parser says to some handler, "I have a foo, do something with it."       Think SAXHandler on a xyz    3. The XMLDomParser is a Push Parser (subclass of SAXHandler) that dynamically creates an XMLDocument.    4. SAXHandler is a Push Parser    5. XPathParserHandler appears to be a pull parser that works on the XMLDocument.    6. Drivers vs Handlers.<a id="org129a665"></a>## Bibliography    https://stackoverflow.com/questions/15895124/what-is-push-approach-and-pull-approach-to-parsing