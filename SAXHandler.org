*  SAXHandler ** Introduction#+BEGIN_EXAMPLE  These are my working notes as I study the Monty XML SAXHandler.  I will be building first a small example  and later a larger exmple  insert something witty and informative here.#+END_EXAMPLE** Todo   get good definitions on Drivers vs Handlers (and other things)** SaxHandler Class Comment#+BEGIN_EXAMPLEThis class is an event-handling XML parser. To use it, subclass it and override event handlers in the "handling" categories, such as #startDocument, #startElement:attributes:, #endElement:, and #endDocument.By default XML namespace support and validation are enabled but not external entity resolution.Once the subclass is ready, use the class "parsing" messages to parse XML:	result := SAXHandlerSubclass parse: xmlStringOrStream.	resultFromURL := SAXHandlerSubclass parseURL: xmlURLString.	resultFromFile := SAXHandlerSubclass parseFileNamed: xmlFileName.The class "instance creation" messages create and return new parsers on the input so they can be configured with messages in the  "configuring" category before parsing:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			isValidating: true;			resolvesExternalEntities: true;			parseDocument.#interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil: 	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			parseDocumentWhile: [self shouldKeepParsing].To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:	(handler := SAXHandlerSubclass on: xmlStringOrStream)		isValidating: false; 		preservesUndeclaredEntityReferences: true.	parser := handler parser.	"Only parse the first 10 tokens:"	10 timesRepeat: [parser parseToken].There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			removeLimits;			documentReadLimit: newReadLimit;			maxEntityReplacementDepth: newMaxEntityDepth;			parseDocument.		#optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.#+END_EXAMPLE** Example Data*** Method One#+BEGIN_EXAMPLE	|ios result|	ios := ReadStream on:'<?xml version="1.0" encoding="UTF-8"?>	<bookstore>	<book category="COOKING">	  <title lang="en">Everyday Italian</title>	  <author>Giada De Laurentiis</author>	  <year>2005</year>	  <price>30.00</price>	</book>	<book category="CHILDREN">	  <title lang="en">Harry Potter</title>	  <author>J K. Rowling</author>	  <year>2005</year>	  <price>29.99</price>	</book>	<book category="WEB">	  <title lang="en">XQuery Kick Start</title>	  <author>James McGovern</author>	  <author>Per Bothner</author>	  <author>Kurt Cagle</author>	  <author>James Linn</author>	  <author>Vaidyanathan Nagarajan</author>	  <year>2003</year>	  <price>49.99</price>	</book>	<book category="WEB">	  <title lang="en">Learning XML</title>	  <author>Erik T. Ray</author>	  <year>2003</year>	  <price>39.95</price>	</book>	</bookstore>'.    result:=ZStudySaxHandler parse: ios.    result inspect.#+END_EXAMPLE*** Method Two	|ios result|	ios := ReadStream on:'<?xml version="1.0" encoding="UTF-8"?>	<bookstore>	<book category="COOKING">	  <title lang="en">Everyday Italian</title>	  <author>Giada De Laurentiis</author>	  <year>2005</year>	  <price>30.00</price>	</book>	<book category="CHILDREN">	  <title lang="en">Harry Potter</title>	  <author>J K. Rowling</author>	  <year>2005</year>	  <price>29.99</price>	</book>	<book category="WEB">	  <title lang="en">XQuery Kick Start</title>	  <author>James McGovern</author>	  <author>Per Bothner</author>	  <author>Kurt Cagle</author>	  <author>James Linn</author>	  <author>Vaidyanathan Nagarajan</author>	  <year>2003</year>	  <price>49.99</price>	</book>	<book category="WEB">	  <title lang="en">Learning XML</title>	  <author>Erik T. Ray</author>	  <year>2003</year>	  <price>39.95</price>	</book>	</bookstore>'.	result :=		(ZStudySaxHandler on: ios)			isValidating: true;			resolvesExternalEntities: true;			parseDocument. ** Interrupting Parsing#+BEGIN_EXAMPLE    #interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil: 	    result :=		    (SAXHandlerSubclass on: xmlStringOrStream)			    parseDocumentWhile: [self shouldKeepParsing].#+END_EXAMPLE** Parse Incrementally#+BEGIN_EXAMPLE    To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:	    (handler := SAXHandlerSubclass on: xmlStringOrStream)		    isValidating: false; 		    preservesUndeclaredEntityReferences: true.	    parser := handler parser.	    "Only parse the first 10 tokens:"	    10 timesRepeat: [parser parseToken].#+END_EXAMPLE** Modifying Security Limits#+BEGIN_EXAMPLE    There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:	    result :=		    (SAXHandlerSubclass on: xmlStringOrStream)			    removeLimits;			    documentReadLimit: newReadLimit;			    maxEntityReplacementDepth: newMaxEntityDepth;			    parseDocument.    #optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.It does this:    optimizeForLargeDocuments	    "use this for faster parsing/less memory use with large documents"	    self		    isValidating: false;		    usesNamespaces: false;		    documentReadLimit: nil#+END_EXAMPLE** Definitions#+BEGIN_EXAMPLE    1. PULL Parser	A pull is when the handler says to the parser, "give me the next foo."	Think XPath on an XMLDocument.    2. PUSH Parser      A push is when the parser says to some handler, "I have a foo, do something with it."       Think SAXHandler on a xyz    3. The XMLDomParser is a Push Parser (subclass of SAXHandler) that dynamically creates an XMLDocument.    4. SAXHandler is a Push Parser    5. XPathParserHandler appears to be a pull parser that works on the XMLDocument.    6. Drivers vs Handlers.#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://stackoverflow.com/questions/15895124/what-is-push-approach-and-pull-approach-to-parsing#+END_EXAMPLE