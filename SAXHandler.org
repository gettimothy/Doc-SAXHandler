*  SAXHandler ** Introduction#+BEGIN_EXAMPLE  These are my working notes as I study the Monty XML SAXHandler.  I will be building first a small example  and later a larger exmple  insert something witty and informative here.#+END_EXAMPLE** Todo   get good definitions on Drivers vs Handlers (and other things)** SaxHandler Class Comment#+BEGIN_EXAMPLEThis class is an event-handling XML parser. To use it, subclass it and override event handlers in the "handling" categories, such as #startDocument, #startElement:attributes:, #endElement:, and #endDocument.By default XML namespace support and validation are enabled but not external entity resolution.Once the subclass is ready, use the class "parsing" messages to parse XML:	result := SAXHandlerSubclass parse: xmlStringOrStream.	resultFromURL := SAXHandlerSubclass parseURL: xmlURLString.	resultFromFile := SAXHandlerSubclass parseFileNamed: xmlFileName.The class "instance creation" messages create and return new parsers on the input so they can be configured with messages in the  "configuring" category before parsing:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			isValidating: true;			resolvesExternalEntities: true;			parseDocument.#interruptParsing can be sent from within a handler to stop parsing, and there is also #parseDocumentWhile: and #parseDocumentUntil: 	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			parseDocumentWhile: [self shouldKeepParsing].To parse incrementally, send #parser to an instance to get the underlying XMLParser object and send it #parseToken repeatedly:	(handler := SAXHandlerSubclass on: xmlStringOrStream)		isValidating: false; 		preservesUndeclaredEntityReferences: true.	parser := handler parser.	"Only parse the first 10 tokens:"	10 timesRepeat: [parser parseToken].There are security limits on input you can remove with #removeLimits or change with messages like #documentReadLimit:	result :=		(SAXHandlerSubclass on: xmlStringOrStream)			removeLimits;			documentReadLimit: newReadLimit;			maxEntityReplacementDepth: newMaxEntityDepth;			parseDocument.		#optimizeForLargeDocuments can be used when parsing large documents if you don't care for validating or namespaces.#+END_EXAMPLE** Definitions#+BEGIN_EXAMPLE    1. PULL Parser	A pull is when the handler says to the parser, "give me the next foo."	Think XPath on an XMLDocument.    2. PUSH Parser      A push is when the parser says to some handler, "I have a foo, do something with it."       Think SAXHandler on a xyz    3. The XMLDomParser is a Push Parser (subclass of SAXHandler) that dynamically creates an XMLDocument.    4. SAXHandler is a Push Parser    5. XPathParserHandler appears to be a pull parser that works on the XMLDocument.    6. Drivers vs Handlers.#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://stackoverflow.com/questions/15895124/what-is-push-approach-and-pull-approach-to-parsing#+END_EXAMPLE